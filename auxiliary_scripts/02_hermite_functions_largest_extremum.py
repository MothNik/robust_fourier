"""
This script aims to evaluate a simple approximation formula for the location of the
largest extremum (= outermost maximum/minimum) of the Hermite functions.
Since the extrema are symmetric around the origin, only the positive extrema are
computed and the negative extrema are obtained by symmetry.

The script is based on an approximation of the largest zero (= outermost root) of the
Hermite functions as well as their numerical fadeout point (where the tail fades below
machine precision).
The largest extremum has to be located between these two points and can be found via
numerical optimisation.

In the end, it was found that a quintic B-spline with only a few knots is sufficient to
represent the largest extrema of the Hermite functions with a decent accuracy.
Therefore, this script auto-generates the B-spline coefficients for the largest
extrema of the Hermite functions and stores them in the Python file that will then be
available within ``robust_hermite_ft``.

NOTE: THIS SCRIPT CAN ONLY BE RUN IF THE DEVELOPER MODE IS ENABLED BY SETTING THE
      ENVIRONMENT VARIABLE ``ROBHERMFT_DEVELOPER`` TO ``true``.

"""

# === Imports ===

import subprocess
import json
import os
from math import sqrt as pysqrt

import numpy as np
from matplotlib import pyplot as plt
from scipy.interpolate import splev, splrep
from scipy.optimize import minimize
from tqdm import tqdm

from robust_hermite_ft.hermite_functions import (
    approximate_hermite_funcs_fadeout_x,
    approximate_hermite_funcs_largest_zeros_x,
    single_hermite_function,
)

plt.style.use(
    os.path.join(os.path.dirname(__file__), "../docs/robust_hermite_ft.mplstyle")
)

# === Constants ===

# the path where the reference data is stored (relative to the current file)
REFERENCE_DATA_FILE_PATH = "./files/02-01_hermite_functions_largest_extrema.npy"
# whether to overwrite the reference data (will trigger a massive computation)
OVERWRITE_REFERENCE_DATA = False

# the path where the diagnostic plot is stored (relative to the current file)
DIAGNOSTIC_PLOT_FILE_PATH = "./files/02-02_hermite_functions_largest_extrema.png"

# the path where to store the spline specifications (relative to the current file)
SPLINE_SPECS_FILE_PATH = (
    "../src/robust_hermite_ft/hermite_functions/_hermite_largest_extrema_spline.py"
)
# the template for storing the spline specifications in the Python file
SPLINE_SPECS_TEMPLATE = """
\"\"\"
Module :mod:`hermite_functions._hermite_largest_extrema_spline`

This file is auto-generated by the script ``auxiliary_scripts/02_hermite_functions_largest_extremum.py``.

This module stores the B-spline specifications for the largest extrema (= outermost
maximum/minimum) of the first ``{order_stop}`` Hermite functions.
The spline is a quintic B-spline with ``{num_knots}`` knots and its maximum absolute relative
error is ``{max_abs_rel_error:.2e}`` with respect to a numerical optimisation which itself is the
limiting factor for the accuracy.

For a diagnostic plot that shows the fit quality, please see
``auxiliary_scripts/{diagnostic_plot_file_path}``.

\"\"\"  # noqa: E501

# === Imports ===

import numpy as np

# === Constants ===

# the specifications of the B-spline for the largest zeros of the Hermite functions
HERMITE_LARGEST_EXTREMA_MAX_ORDER = {order_stop}
HERMITE_LARGEST_EXTREMA_SPLINE_TCK = (
    np.array({knots}),
    np.array({coefficients}),
    {degree},
)

"""

# whether to overwrite the spline coefficients file
OVERWRITE_SPLINE_SPECS = True

# the number of grid points for the initial bracketing of the extremum
NUM_EVAL = 100
# the x and gradient tolerances for the optimisation
OPT_XTOL = 1e-13
OPT_GTOL = 1e-15
# the maximum number of iterations for the optimisation
MAX_ITER = 100_000

# the orders and spacings of the Hermite functions to evaluate
ORDER_START = 1  # for order 0 the extremum is exactly x=0
ORDERS_AND_SPACINGS = [
    (100, 1),  # order to, spacing
    (250, 2),
    (500, 4),
    (1_000, 8),
    (2_500, 16),
    (5_000, 32),
    (10_000, 64),
    (25_000, 128),
    (50_000, 256),
    (100_512, 512),
]
# the degree of the B-spline
SPLINE_DEGREE = 5
# the maximum relative tolerance for the extrema evaluated by the spline
X_MAX_RTOL = 1e-12

# === Functions ===


def _hermite_func_first_derivative(
    x: np.ndarray,
    n: int,
) -> np.ndarray:
    """
    Evaluates the first derivative of the Hermite function of order ``n`` at the
    position ``x``.

    """

    # the first derivative is given as a weighted sum of the Hermite functions of order
    # ``n-1`` and ``n+1``
    return pysqrt(n / 2) * single_hermite_function(x=x, n=n - 1) - pysqrt(
        (n + 1) / 2
    ) * single_hermite_function(x=x, n=n + 1)


def _hermite_func_second_derivative(
    x: np.ndarray,
    n: int,
) -> np.ndarray:
    """
    Evaluates the second derivative of the Hermite function of order ``n`` at the
    position ``x``.

    """

    # the second derivative is given as a weighted sum of the first derivatives of the
    # Hermite functions of order ``n-1`` and ``n+1``
    return pysqrt(n / 2) * _hermite_func_first_derivative(x=x, n=n - 1) - pysqrt(
        (n + 1) / 2
    ) * _hermite_func_first_derivative(x=x, n=n + 1)


def find_hermite_functions_largest_extremum_x(n: int) -> float:
    """
    Finds the location of the largest extremum of the Hermite function of order ``n``.

    """

    # an initial guess for the location of the largest extremum is made by bracketing it
    # between the largest zero and the fadeout point
    x_largest_zero = approximate_hermite_funcs_largest_zeros_x(n=n)[-1]
    x_fadeout = approximate_hermite_funcs_fadeout_x(n=n)[-1]

    # the extremum is bracketed between the largest zero and the fadeout point;
    # over this range, the first derivative of the Hermite function is evaluated and
    # checked for a sign change
    # NOTE: the fadeout point is way too conservative and therefore the bracketing is
    #       done with a smaller range
    x_values_initial = np.linspace(
        start=x_largest_zero, stop=x_largest_zero + 0.2 * (x_fadeout - x_largest_zero), num=NUM_EVAL,
    )
    hermite_derivative_values = _hermite_func_first_derivative(
        x=x_values_initial,
        n=n,
    )

    # the sign change is used to find the initial interval of the extremum
    sign_change_index = np.where(
        np.sign(hermite_derivative_values[:-1])
        != np.sign(hermite_derivative_values[1:])
    )[0][0]

    # a bounded interval around the sign change is used to find the extremum
    if sign_change_index.size < 1:
        raise RuntimeError("No sign change found for the Hermite function derivative.")

    lower_bound, upper_bound = x_values_initial[
        sign_change_index : sign_change_index + 2
    ]

    # the extremum is found via numerical optimisation
    # NOTE: for the positive x-values, the extremum is a maximum
    # NOTE: for order 1, the second derivative is not available and the optimisation
    #       method is changed to "Newton-CG" with a numerical approximation of the
    #       Hessian
    if n > 1:
        opt_method = "trust-exact"
        opt_kwargs = dict(
            hess=lambda x: -_hermite_func_second_derivative(x=x, n=n)[0],
            options=dict(maxiter=MAX_ITER, gtol=OPT_GTOL),
        )
    else:
        opt_method = "Newton-CG"
        opt_kwargs = dict(
            hess="3-point",
            options=dict(maxiter=MAX_ITER, xtol=OPT_XTOL),
        )

    result = minimize(
        fun=lambda x: -single_hermite_function(x=x, n=n)[0],
        jac=lambda x: -_hermite_func_first_derivative(x=x, n=n)[0],
        x0=(lower_bound + upper_bound) / 2,
        method=opt_method,
        **opt_kwargs,
    )

    # a final sanity check is made to ensure that the unbounded optimisation did not
    # leave its bounds
    if not (x_largest_zero <= result.x[0] <= x_fadeout):
        raise RuntimeError("Optimisation result out of bounds.")

    return result.x[0]


# === Main ===

if (
    __name__ == "__main__"
    and os.getenv("ROBHERMFT_DEVELOPER", "false").lower() == "true"
):

    # --- Reference data loading / computation ---

    # if available and enabled, the reference data is loaded
    reference_file_path = os.path.join(
        os.path.dirname(__file__), REFERENCE_DATA_FILE_PATH
    )
    try:
        if OVERWRITE_REFERENCE_DATA:
            raise FileNotFoundError()

        reference_data = np.load(reference_file_path, allow_pickle=False)
        orders, outerm_extremum_x_positions = (
            reference_data[::, 0],
            reference_data[::, 1],
        )

    # otherwise, the reference data is computed
    except (FileNotFoundError, NotADirectoryError):
        order_start = ORDER_START
        orders = []
        for order_end, spacing in ORDERS_AND_SPACINGS:
            orders.extend(range(order_start, order_end, spacing))
            order_start = order_end

        orders = np.array(orders, dtype=np.int64)
        outerm_extremum_x_positions = np.empty_like(orders, dtype=np.float64)

        progress_bar = tqdm(total=len(orders), desc="Computing outermost extrema")
        for idx, n in enumerate(orders):
            outerm_extremum_x_positions[idx] = (
                find_hermite_functions_largest_extremum_x(n=int(n))
            )
            progress_bar.update(1)

        # the reference data is stored
        np.save(
            reference_file_path,
            np.column_stack((orders, outerm_extremum_x_positions)),
            allow_pickle=False,
        )

    # --- Spline fitting ---

    # the spline is fitted with an ever decreasing smoothing value s until the
    # maximum absolute error drops below the threshold
    max_abs_rel_error = np.inf
    s_value = 1e-10
    weights = np.reciprocal(outerm_extremum_x_positions)  # all > 0
    # tck = None
    # outerm_extremum_x_positions_approx = None
    while max_abs_rel_error > X_MAX_RTOL and s_value > 1e-30:
        tck = splrep(
            x=orders,
            y=outerm_extremum_x_positions,
            w=weights,
            k=SPLINE_DEGREE,
            s=s_value,
        )
        outerm_extremum_x_positions_approx = splev(x=orders, tck=tck)

        max_abs_error = np.abs(
            (outerm_extremum_x_positions - outerm_extremum_x_positions_approx) * weights
        ).max()
        s_value /= 10.0**0.25

    assert (
        tck is not None and outerm_extremum_x_positions_approx is not None
    ), "No spline was fitted, please re-adjust the tolerances and smoothing values."
    print(
        f"\nFinal number of spline knots: {len(tck[0])} for smoothing value "
        f"{s_value=:.2e}"
    )

    # the spline coefficients are stored (if enabled)
    if OVERWRITE_SPLINE_SPECS:
        spline_specs_file_path = os.path.join(
            os.path.dirname(__file__), SPLINE_SPECS_FILE_PATH
        )

        # the Python-file is created from the template ...
        with open(spline_specs_file_path, "w") as spline_specs_file:
            spline_specs_file.write(
                SPLINE_SPECS_TEMPLATE.format(
                    order_stop=round(orders[-1]),
                    num_knots=len(tck[0]),
                    max_abs_rel_error=X_MAX_RTOL,
                    diagnostic_plot_file_path=DIAGNOSTIC_PLOT_FILE_PATH,
                    knots=json.dumps(tck[0].tolist()),  # type: ignore
                    coefficients=json.dumps(tck[1].tolist()),
                    degree=SPLINE_DEGREE,
                )
            )

        # ... and formatted
        subprocess.run(["black", spline_specs_file_path])

    # --- Diagnostic plot ---

    fig, ax = plt.subplots(
        nrows=2,
        sharex=True,
        figsize=(12, 8),
    )

    ax[0].plot(  # type: ignore
        orders,
        outerm_extremum_x_positions,
        color="red",
        label="Optimised Extrema",
    )
    ax[0].plot(  # type: ignore
        orders,
        outerm_extremum_x_positions_approx,
        color="#00CCCC",
        label="Spline Approximation",
    )

    ax[1].axhline(0.0, color="black", linewidth=0.5)  # type: ignore
    ax[1].plot(  # type: ignore
        orders,
        100.0
        * weights
        * (outerm_extremum_x_positions - outerm_extremum_x_positions_approx),
        color="#00CCCC",
        zorder=2,
        label="Difference",
    )
    ax[1].axhline(  # type: ignore
        100.0 * X_MAX_RTOL,
        color="#FF007F",
        linestyle="--",
        label="Threshold",
        linewidth=2.0,
        zorder=0,
    )
    ax[1].axhline(  # type: ignore
        -100.0 * X_MAX_RTOL,
        color="#FF007F",
        linestyle="--",
        linewidth=2.0,
        zorder=1,
    )
    ax[1].scatter(  # type: ignore
        tck[0],
        np.zeros_like(tck[0]),
        s=60,
        marker=6,
        color="purple",
        label="Knots",
        zorder=3,
    )

    ax[0].set_ylabel("Largest Extremum Position")  # type: ignore
    ax[1].set_ylabel(r"Approximation Error $\left(\%\right)$")  # type: ignore
    ax[1].set_xlabel("Hermite Function Order")  # type: ignore

    ax[1].set_xlim(orders[0], orders[-1])  # type: ignore

    ax[0].legend()  # type: ignore
    ax[1].legend()  # type: ignore

    # the plot is stored (if the spline coefficients were stored)
    if OVERWRITE_SPLINE_SPECS:
        diagnostic_plot_file_path = os.path.join(
            os.path.dirname(__file__), DIAGNOSTIC_PLOT_FILE_PATH
        )
        fig.savefig(diagnostic_plot_file_path)

    plt.show()
