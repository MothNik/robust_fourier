"""
This script aims to evaluate a simple - maybe only crude - approximation of the
outermost oscillation (tail) of the Hermite functions.

The idea is to fit the tail with a Gaussian peak and save its standard deviation. Since
the peak will only be a shifted unscaled squared exponential function, its amplitude at
the center is exactly 1. To obtain the correct center and amplitude, the approximations
of the x- and y-positions of the maximum of the tail are thus also required, but these
are generated via the auxiliary script ``02_hermite_functions_largest_extremum.py``.

In the end, it was found that quintic B-splines with only a few knots are sufficient to
represent the standard deviations of the peaks for the approximation of the tail.

Therefore, this script auto-generates the B-spline coefficients for these two parameters
of the Hermite functions and stores them in the Python file that will then be available
within ``robust_fourier``.

NOTE: THIS SCRIPT CAN ONLY BE RUN IF THE DEVELOPER MODE IS ENABLED BY SETTING THE
      ENVIRONMENT VARIABLE ``ROBFT_DEVELOPER`` TO ``true``.

"""

# === Imports ===

import json
import os
import subprocess
from typing import Callable

import numpy as np
from matplotlib import pyplot as plt
from scipy.interpolate import splev, splrep
from scipy.optimize import curve_fit
from tqdm import tqdm

from robust_fourier.hermite_functions import hermite_approx, single_hermite_function

plt.style.use(
    os.path.join(os.path.dirname(__file__), "../docs/robust_fourier.mplstyle")
)


# === Constants ===

# the path where the reference data is stored (relative to the current file)
REFERENCE_DATA_FILE_PATH = "./files/03-01_hermite_functions_tail_gauss_sigmas.npy"
# whether to overwrite the reference data (will trigger a massive computation in the
# order of 5 ... 20 minutes)
OVERWRITE_REFERENCE_DATA = False

# the path where the diagnostic plot is stored (relative to the current file)
DIAGNOSTIC_PLOT_FILE_PATH_SIGMAS = (
    "./files/03-02_hermite_functions_tail_gauss_sigmas.svg"
)

# the orders and spacings of the Hermite functions to evaluate
ORDER_START = 1  # for order 0 the standard deviation is exactly 1
ORDERS_AND_SPACINGS = [
    (100, 1),  # order to, spacing
    (250, 2),
    (500, 4),
    (1_000, 8),
    (2_500, 16),
    (5_000, 32),
    (10_000, 64),
    (25_000, 128),
    (50_000, 256),
    (100_512, 512),
]

# the path where to store the spline specifications (relative to the current file)
SPLINE_SPECS_FILE_PATH = (
    "../src/robust_fourier/hermite_functions/_hermite_tail_gauss_sigma_spline.py"
)
# the template for storing the spline specifications in the Python file
SPLINE_SPECS_TEMPLATE = """
\"\"\"
Module :mod:`hermite_functions.{file_name}`

This file is auto-generated by the script ``auxiliary_scripts/03_hermite_functions_tail_approximation.py``.

This module stores the B-spline specifications for the standard deviations of the
Gaussian peaks to approximate the outermost oscillation (tail) of the first ``{order_stop}``
Hermite functions. For their centers and amplitudes, please check the function :func:`x_and_y_largest_extrema`
from the module :mod:`hermite_functions._approximations`.

For the standard deviation sigma, the spline is a quintic B-splines with ``{num_knots}`` knots
and its maximum absolute relative error is ``{max_abs_rel_error:.2e}`` with respect to the crude
Gaussian peak approximation.
Besides, it is a function of the natural logarithm of the Hermite function order.

For diagnostic plots that show the fit quality, please see
``auxiliary_scripts/{sigma_diagnostic_plot_file_path}``.

\"\"\"  # noqa: E501

# === Imports ===

import numpy as np

# === Constants ===

# the specifications of the B-spline for the standard deviations sigma of the Gaussian
# peaks to approximate the outermost oscillation (tail) of the Hermite functions
HERMITE_TAIL_GAUSS_APPROX_MAX_ORDER = {order_stop}
HERMITE_TAIL_GAUSS_SIGMA_SPLINE_TCK = (
    np.array({knots}),
    np.array({coefficients}),
    {degree},
)

"""  # noqa: E501

# whether to overwrite the spline coefficients file
OVERWRITE_SPLINE_SPECS = True

# the number of x-values for the evaluation of the Gaussian peak
NUM_X_VALUES = 10_000
# the minimum cumulative sum that the x-values must contribute to the Gaussian peak
MIN_CUMULATIVE_SUM = 0.999

# the degree of the B-splines
SPLINE_DEGREE = 5
# the maximum relative tolerance for the Gaussian standard deviation evaluated by the
# splines
SIGMA_MAX_RTOL = 1e-12

# === Functions ===


def _generate_gaussian_peak_function(
    x_from: float,
    amplitude: float,
) -> Callable[..., np.ndarray]:
    """
    Generates a Gaussian peak function with a fixed amplitude and center that evaluates
    the peak at the given x-values with a standard deviation as a parameter.

    """

    def gaussian_peak_function(
        x: float,
        sigma: float,
    ) -> np.ndarray:

        return amplitude * np.exp(-0.5 * np.square((x - x_from) / sigma))

    return gaussian_peak_function


def _get_hermite_tail_sigma(
    n: int,
    start_value: float,
) -> float:
    """
    Computes the standard deviation of the Gaussian peak that approximates the tail of
    the Hermite function of order ``n``.

    """

    # the x-values for the evaluation of the Hermite function are determined
    x_from = hermite_approx.x_largest_extrema(
        n=n,
        alpha=1.0,
        x_center=None,
    ).max()
    x_to = hermite_approx.x_fadeout(
        n=n,
        alpha=1.0,
        x_center=None,
    ).max()

    x_values = np.linspace(
        start=x_from,
        stop=x_to,
        num=NUM_X_VALUES,
    )

    # the Hermite function is evaluated
    hermite_values = single_hermite_function(
        x=x_values,
        n=n,
        alpha=1.0,
        x_center=None,
    )

    # the points of the tail to fit are determined by the cumulative sum
    # NOTE: they are all positive, so the cumulative sum is monotonically increasing
    rel_cumsum_values = np.cumsum(hermite_values) / np.sum(hermite_values)
    tail_indices = np.where(rel_cumsum_values >= MIN_CUMULATIVE_SUM)[0]

    # the Gaussian peak is fitted to the tail
    gauss_peak_function = _generate_gaussian_peak_function(
        x_from=x_from,
        amplitude=hermite_values[0],
    )
    optimal_params, _ = curve_fit(
        f=gauss_peak_function,
        xdata=x_values[tail_indices],
        ydata=hermite_values[tail_indices],
        p0=[start_value],
    )

    return optimal_params[0]


# === Main ===

if __name__ == "__main__" and os.getenv("ROBFT_DEVELOPER", "false").lower() == "true":

    # --- Reference data loading / computation ---

    # if available and enabled, the reference data is loaded
    reference_file_path = os.path.join(
        os.path.dirname(__file__), REFERENCE_DATA_FILE_PATH
    )
    try:
        if OVERWRITE_REFERENCE_DATA:
            raise FileNotFoundError()

        reference_data = np.load(reference_file_path, allow_pickle=False)
        orders, sigmas_tail_gauss = (
            reference_data[::, 0],
            reference_data[::, 1],
        )

    # otherwise, the reference data is computed
    except (FileNotFoundError, NotADirectoryError):
        order_start = ORDER_START
        orders = []
        for order_end, spacing in ORDERS_AND_SPACINGS:
            orders.extend(range(order_start, order_end, spacing))
            order_start = order_end

        orders = np.array(orders, dtype=np.int64)
        sigmas_tail_gauss = np.empty_like(orders, dtype=np.float64)

        progress_bar = tqdm(total=len(orders), desc="Computing Gaussian fits")
        sigma_current = 1.0  # for order 0
        for idx, n in enumerate(orders):
            sigma_current = _get_hermite_tail_sigma(
                n=n,
                start_value=sigma_current,
            )
            sigmas_tail_gauss[idx] = sigma_current
            progress_bar.update(1)

        # the reference data is stored
        np.save(
            reference_file_path,
            np.column_stack((orders, sigmas_tail_gauss)),
            allow_pickle=False,
        )

    # --- Spline fitting ---

    # the spline is fitted with an ever decreasing smoothing value s until the
    # maximum absolute error drops below the threshold
    max_abs_rel_error = np.inf
    s_value = 1e-10
    log_orders = np.log(orders)
    sigma_weights = np.reciprocal(sigmas_tail_gauss)  # all > 0
    sigma_tck = None
    sigma_tail_gauss_approx = None
    while max_abs_rel_error > SIGMA_MAX_RTOL and s_value > 1e-30:
        sigma_tck = splrep(
            x=log_orders,
            y=sigmas_tail_gauss,
            w=sigma_weights,
            k=SPLINE_DEGREE,
            s=s_value,
        )
        sigma_tail_gauss_approx = splev(x=log_orders, tck=sigma_tck)

        max_abs_error = np.abs(
            (sigmas_tail_gauss - sigma_tail_gauss_approx) * sigma_weights
        ).max()
        s_value /= 10.0**0.25

    assert sigma_tck is not None and sigma_tail_gauss_approx is not None, (
        "No spline was fitted for the Gaussian standard deviations, please re-adjust "
        "the tolerances and smoothing values."
    )
    print(
        f"\nFinal number of spline knots for the Gaussian standard deviations: "
        f"{len(sigma_tck[0])} for smoothing value {s_value=:.2e}"
    )

    # the spline coefficients are stored (if enabled)
    if OVERWRITE_SPLINE_SPECS:
        spline_specs_file_path = os.path.join(
            os.path.dirname(__file__), SPLINE_SPECS_FILE_PATH
        )

        # the Python-file is created from the template ...
        with open(spline_specs_file_path, "w") as spline_specs_file:
            spline_specs_file.write(
                SPLINE_SPECS_TEMPLATE.format(
                    file_name=SPLINE_SPECS_FILE_PATH.split("/")[-1].split(".")[0],
                    order_stop=round(orders[-1]),
                    num_knots=len(sigma_tck[0]),
                    max_abs_rel_error=SIGMA_MAX_RTOL,
                    sigma_diagnostic_plot_file_path=(
                        DIAGNOSTIC_PLOT_FILE_PATH_SIGMAS.split("/")[-1]
                    ),
                    knots=json.dumps(sigma_tck[0].tolist()),  # type: ignore  # noqa: E501
                    coefficients=json.dumps(sigma_tck[1].tolist()),
                    degree=SPLINE_DEGREE,
                )
            )

        # ... and formatted
        subprocess.run(["black", spline_specs_file_path])

    # --- Diagnostic plot ---

    fig_sigma, ax_sigma = plt.subplots(
        nrows=2,
        sharex=True,
        figsize=(12, 8),
    )

    ax_sigma[0].plot(  # type: ignore
        log_orders,
        sigmas_tail_gauss,
        color="red",
        label="Evaluated Standard Deviations",
    )
    ax_sigma[0].plot(  # type: ignore
        log_orders,
        sigma_tail_gauss_approx,
        color="#00CCCC",
        label="Spline Approximation",
    )

    ax_sigma[1].axhline(0.0, color="black", linewidth=0.5)  # type: ignore
    ax_sigma[1].plot(  # type: ignore
        log_orders,
        100.0 * sigma_weights * (sigmas_tail_gauss - sigma_tail_gauss_approx),
        color="#00CCCC",
        zorder=2,
        label="Difference",
    )
    ax_sigma[1].axhline(  # type: ignore
        100.0 * SIGMA_MAX_RTOL,
        color="#FF007F",
        linestyle="--",
        label="Threshold",
        linewidth=2.0,
        zorder=0,
    )
    ax_sigma[1].axhline(  # type: ignore
        -100.0 * SIGMA_MAX_RTOL,
        color="#FF007F",
        linestyle="--",
        linewidth=2.0,
        zorder=1,
    )
    ax_sigma[1].scatter(  # type: ignore
        sigma_tck[0],
        np.zeros_like(sigma_tck[0]),
        s=60,
        marker=6,
        color="purple",
        label="Knots",
        zorder=3,
    )

    ax_sigma[0].set_ylabel("Gaussian Peak\nStandard Deviation")  # type: ignore
    ax_sigma[1].set_ylabel(r"Approximation Error $\left(\%\right)$")  # type: ignore
    ax_sigma[1].set_xlabel("Natural Logarithm of Hermite Function Order")  # type: ignore # noqa: E501

    ax_sigma[1].set_xlim(log_orders[0], log_orders[-1])  # type: ignore

    ax_sigma[0].legend()  # type: ignore
    ax_sigma[1].legend()  # type: ignore

    fig_sigma.suptitle(
        "Standard Deviations of Outermost Oscillations Gaussian Peaks",
        fontsize=18,
    )

    # the plots are stored (if the spline coefficients were stored)
    if OVERWRITE_SPLINE_SPECS:
        sigma_diagnostic_plot_file_path = os.path.join(
            os.path.dirname(__file__), DIAGNOSTIC_PLOT_FILE_PATH_SIGMAS
        )
        fig_sigma.savefig(sigma_diagnostic_plot_file_path)

    plt.show()

elif __name__ == "__main__":
    print(
        "This script can only be run if the developer mode is enabled by setting the "
        "environment variable 'ROBFT_DEVELOPER' to 'true'."
    )
